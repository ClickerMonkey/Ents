/* 
 * NOTICE OF LICENSE
 * 
 * This source file is subject to the Open Software License (OSL 3.0) that is 
 * bundled with this package in the file LICENSE.txt. It is also available 
 * through the world-wide-web at http://opensource.org/licenses/osl-3.0.php
 * If you did not receive a copy of the license and are unable to obtain it 
 * through the world-wide-web, please send an email to magnos.software@gmail.com 
 * so we can send you a copy immediately. If you use any of this software please
 * notify me via our website or email, your feedback is much appreciated. 
 * 
 * @copyright   Copyright (c) 2011 Magnos Software (http://www.magnos.org)
 * @license     http://opensource.org/licenses/osl-3.0.php
 * 				Open Software License (OSL 3.0)
 */

package org.magnos.entity;

import org.magnos.entity.util.BitSet;
import org.magnos.entity.util.ComponentSet;
import org.magnos.entity.util.ControllerSet;
import org.magnos.entity.util.EntityUtility;
import org.magnos.entity.util.IndexPool;


/**
 * An Entity is a game object that may be drawn, may be updated, has a set of
 * components, has a set of controllers that modifies it's state, and optionally
 * a view which handles the drawing. <br/>
 * <br/>
 * An entity by default is not expired, is visible, and is enabled. <br/>
 * <br/>
 * When an entity expires, the object containing the Entity is responsible from
 * removing it from the world. An expired Entity is one that is ready to be
 * entirely forgotten by the world and should not be drawn or updated. However,
 * an Entity could be expired and the {@link #update(Object)} and
 * {@link #draw(Object)} methods may still work, it's the job of the container
 * to check for expiration.
 * 
 * @author Philip Diffenderfer
 * 
 */
@SuppressWarnings ("unchecked" )
public class Entity
{

    /**
     * The unique non-negative identifier for this entity. This is generated by
     * {@link Ents} and is garunteed that no other active (non-deleted) entity
     * will have the same ID.
     * 
     * @see IndexPool
     */
    public final int id;

    /**
     * The template of the Entity.
     */
    protected Template template;

    /**
     * The entity's distinct component values.
     */
    protected Object[] values;

    /**
     * Which controllers are enabled.
     */
    protected BitSet controllerEnabled;

    /**
     * The current Renderer of the entity.
     */
    protected Renderer renderer;

    /**
     * If the entity is expired, it is up for deletion by the parent Entity.
     */
    protected boolean expired = false;

    /**
     * If the entity is visible, the {@link #renderer} of the entity is
     * invoked when the {@link #draw(Object)} method is invoked.
     */
    protected boolean visible = true;

    /**
     * If the entity is enabled, the enabled controllers of the entity is
     * invoked when the {@link #update(Object)} method is invoked.
     */
    protected boolean enabled = true;

    /**
     * Instantiates a custom entity that by default does not have components,
     * controllers, or a view.
     */
    public Entity()
    {
        this( Ents.newTemplate() );
    }

    /**
     * Instantiates a custom entity with a set of components, without any
     * controllers, and without a view.
     * 
     * @param components
     *        The set of components to add to the Entity.
     */
    public Entity( Component<?>... components )
    {
        this( new ComponentSet( components ), ControllerSet.NONE, View.NONE );
    }

    /**
     * Instantiates a custom entity with a set of components, controllers, and
     * without a view.
     * 
     * @param componentSet
     *        The set of components to add to the Entity.
     * @param controllerSet
     *        The set of controllers to add to the Entity.
     */
    public Entity( ComponentSet componentSet, ControllerSet controllerSet )
    {
        this( componentSet, controllerSet, View.NONE );
    }

    /**
     * Instantiates a custom entity with a set of components, controllers, and a
     * view.
     * 
     * @param componentSet
     *        The set of components to add to the Entity.
     * @param controllerSet
     *        The set of controllers to add to the Entity.
     * @param view
     *        The view for the entity.
     */
    public Entity( ComponentSet componentSet, ControllerSet controllerSet, View view )
    {
        this( new Template( componentSet, controllerSet, view ) );
    }

    /**
     * Instantiates an Entity given a {@link Template}. This entity will have
     * the Template's components, controllers, and view. <br/>
     * <br/>
     * All controllers that exist in the Template are enabled by default on the
     * Entity. In other words, when update is called after Entity creation all
     * controllers will modify the Entity. To control which controllers are
     * enabled use the {@link #setControllerEnabled(Controller, boolean)} method
     * (or any of it's variants).
     * 
     * @param template
     *        The template of the Entity.
     */
    public Entity( Template template )
    {
        this( template, template.createDefaultValues(), template.createRenderer() );
    }

    /**
     * Instantiates an Entity given a template and the Entity's default values.
     * 
     * @param template
     *        The template of the Entity.
     * @param values
     *        The default values of the entity.
     */
    protected Entity( Template template, Object[] values, Renderer renderer )
    {
        this.setTemplate( template );
        this.setRenderer( renderer );
        this.values = values;
        this.controllerEnabled = new BitSet( template.controllers.length, true );
        this.id = Ents.register( this );
        this.template.addToComponents( this );
    }

    /**
     * Internally sets the Template of the entity notifying the existing
     * Template (if any) that it has one last Entity instance as well as
     * notifying the new Template that it has a new Entity instance. The given
     * template will always be either the same as the current template or an
     * extension of it. It should never be a template with fewer components or
     * controllers.
     * 
     * @param newTemplate
     *        The new template of the Entity.
     * @return True if the template given is different than the existing
     *         template.
     */
    private boolean setTemplate( Template newTemplate )
    {
        boolean changed = (template != newTemplate);

        if (changed)
        {
            if (template != null)
            {
                template.removeInstance( this );
            }

            (template = newTemplate).newInstance( this );
        }

        return changed;
    }

    /**
     * @return True if the Entity has expired, otherwise false.
     */
    public boolean isExpired()
    {
        return expired;
    }

    /**
     * Expires the entity, setting off the flag that let's any container know
     * that this Entity should no longer be held (or drawn and updated) and
     * {@link #delete()} should be invoked.
     */
    public void expire()
    {
        expired = true;
    }

    /**
     * This removes this Entity from the Template and destroys the Entity's
     * Renderer. Once this method is called, this Entity should not by used,
     * all methods will most likely result in a {@link NullPointerException}. <br/>
     * <br/>
     * If the entity is added to an Entity collection, delete will be called
     * whenever the {@link #update(Object)} or {@link EntityList#clean()} is
     * called and this entity is expired. It will also cause this entity to
     * removed from its container.
     */
    public boolean delete()
    {
        boolean deletable = (template != null);

        if (deletable)
        {
            if (renderer != null)
            {
                renderer.destroy( this );
            }

            Ents.unregister( this );

            template.removeFromComponents( this );
            template.removeInstance( this );

            template = null;
            renderer = null;
            expired = true;
        }

        return deletable;
    }

    /**
     * Determines whether this Entity has been deleted.
     * 
     * @return True if the Entity has been deleted, otherwise false.
     */
    public boolean isDeleted()
    {
        return (template == null);
    }

    /**
     * Sets the visibility of this Entity to the given value.
     * 
     * @param visible
     *        True if the {@link #draw(Object)} method should have any effect,
     *        otherwise false.
     */
    public void setVisible( boolean visible )
    {
        this.visible = visible;
    }

    /**
     * Sets the visibility of this Entity to true. If this entity has a view,
     * {@link Renderer#draw(Entity, Object)} will be called with the drawState
     * passed into draw as well as the reference to this Entity.
     */
    public void show()
    {
        visible = true;
    }

    /**
     * Sets the visibility of this Entity to false. This entity will not be
     * drawn.
     */
    public void hide()
    {
        visible = false;
    }

    /**
     * @return True if the Entity is visible, otherwise false.
     */
    public boolean isVisible()
    {
        return visible;
    }

    /**
     * Draws the Entity if it's visible and has a {@link View}, by passing the
     * drawState and this Entity to it's View.
     * 
     * @param drawState
     *        An object to pass to the view which enables this Entity to be
     *        drawn on the chosen medium.
     */
    public void draw( Object drawState )
    {
        if (visible && renderer != null)
        {
            renderer.begin( this, drawState );
            renderer.end( this, drawState );
        }
    }

    /**
     * Determines whether this Entity has the given view (or an alternative).
     * This returns whether the view passed in has the same ID as the current
     * view of the Entity, it does not check to see if it's literally the exact
     * same view.
     * 
     * @param view
     *        The view to check for.
     * @return True if this Entity has the given view (or an alternative),
     *         otherwise false.
     */
    public boolean has( View view )
    {
        return template.has( view );
    }

    /**
     * @return True if this Entity has a view at all, otherwise false.
     */
    public boolean hasView()
    {
        return template.hasView();
    }

    /**
     * Determines if this Entity has a non-null renderer. Even if the renderer
     * is non-null it might not be called if the entity is marked as invisible.
     * 
     * @return True if this Entity has a non-null renderer.
     */
    public boolean hasRenderer()
    {
        return renderer != null;
    }

    /**
     * Returns the reference to the {@link Renderer} for this Entity. The
     * {@link Renderer#create(Entity)} and {@link Renderer#destroy(Entity)}
     * should not be called on the Renderer returned, it may negatively affect
     * the rendering of this Entity and even the application. <br/>
     * <br/>
     * The reference returned was created by invoking
     * {@link #setRenderer(Renderer)}, or by having a non-null view and causing
     * {@link Renderer#create(Entity)} to be called and the returned reference
     * be used.
     * 
     * @return The reference to this Entity's renderer, or null.
     */
    public Renderer getRenderer()
    {
        return renderer;
    }

    /**
     * Returns the {@link View} associated with this Entity. The view holds the
     * {@link Renderer} that's responsible for drawing this Entity. Even if the
     * view is null this Entity can still have a Renderer if the
     * {@link #setRenderer(Renderer)} method was invoked with a non-null
     * Renderer.
     * 
     * @return The reference to the View for this Entity.
     */
    public View getView()
    {
        return template.getView();
    }

    /**
     * Sets whether this entity is enabled or not. An enabled entity (true) will
     * invoke it's controllers when {@link #update(Object)} is called, while a
     * disabled entity (false) does not. <br/>
     * <br/>
     * Even if the entity is enabled, it's controllers need to be enabled as
     * well using the {@link #setControllerEnabled(Controller, boolean)} method
     * or it's variants.
     * 
     * @param enabled
     *        True if the entity should be enabled, otherwise false.
     */
    public void setEnabled( boolean enabled )
    {
        this.enabled = enabled;
    }

    /**
     * Enables this entity, calling any enabled controllers when
     * {@link #update(Object)} is called.
     * 
     * @see #setEnabled(boolean)
     */
    public void enable()
    {
        enabled = true;
    }

    /**
     * Disables this entity, {@link #update(Object)} will have no affect.
     * 
     * @see #setEnabled(boolean)
     */
    public void disable()
    {
        enabled = false;
    }

    /**
     * @return True if the entity is enabled, otherwise false.
     * @see #setEnabled(boolean)
     */
    public boolean isEnabled()
    {
        return enabled;
    }

    /**
     * Updates the Entity if it's enabled. To update an entity, all enabled
     * controllers on the Entity are invoked passing the Entity reference and
     * the given updateState.
     * 
     * @param updateState
     *        An object to pass to the controller's control method.
     */
    public void update( Object updateState )
    {
        if (enabled)
        {
            final Controller[] controllers = template.controllers;

            for (int i = 0; i < controllers.length; i++)
            {
                final Controller c = controllers[i];

                if (controllerEnabled.get( template.indexOf( c ) ))
                {
                    c.control.update( this, updateState );
                }
            }
        }
    }

    /**
     * Determines whether the given {@link Controller} (or an alternative) is
     * enabled for this Entity. If the controller doesn't exist, an
     * {@link IndexOutOfBoundsException} will be thrown. To avoid an exception,
     * {@link #has(Controller)} should be tested first. If this method returns
     * true, {@link Control#update(Entity, Object)} is called on the controller
     * if {@link #isEnabled()} is true and {@link #update(Object)} is invoked.
     * 
     * @param controller
     *        The controller to check for being enabled.
     * @return True if the controller exists in this Entity and it's enabled.
     */
    public boolean isControllerEnabled( Controller controller )
    {
        return controllerEnabled.get( template.indexOf( controller ) );
    }

    /**
     * Sets whether the given controller is enabled on this Entity. If this
     * Entity doesn't have the given Controller (or an alternative) then an
     * {@link IndexOutOfBoundsException} is thrown. To avoid an exception,
     * {@link #has(Controller)} should be tested first. An enabled controller
     * will have it's {@link Control#update(Entity, Object)} method invoked
     * if {@link #isEnabled()} is true and {@link #update(Object)} is invoked.
     * 
     * @param controller
     *        The controller to enable or disable.
     * @param enabled
     *        True to enable the controller, false to disable it.
     */
    public void setControllerEnabled( Controller controller, boolean enabled )
    {
        controllerEnabled.set( template.indexOf( controller ), enabled );
    }

    /**
     * Enables or disables all controllers that exist in this Entity.
     * 
     * @param enabled
     *        True if all controllers should be enabled, otherwise false.
     */
    public void setControllerEnabledAll( boolean enabled )
    {
        controllerEnabled.set( 0, template.controllers.length, enabled );
    }

    /**
     * Enables the given controller on this Entity. If this Entity does not
     * have the controller (or an alternative) an IndexOutOfBoundsException will
     * be thrown.
     * 
     * @param controller
     *        The controller to enable on this Entity.
     * @throws IndexOutOfBoundsException
     */
    public void enable( Controller controller )
    {
        setControllerEnabled( controller, true );
    }

    /**
     * Disables the given controller on this Entity. If this Entity does not
     * have the controller (or an alternative) an IndexOutOfBoundsException will
     * be thrown.
     * 
     * @param controller
     *        The controller to enable on this Entity.
     * @throws IndexOutOfBoundsException
     */
    public void disable( Controller controller )
    {
        setControllerEnabled( controller, false );
    }

    /**
     * Determines whether this Entity has the given controller.
     * 
     * @param controller
     *        The controller to test for existence.
     * @return True if the entity has the controller, otherwise false.
     */
    public boolean has( Controller controller )
    {
        return template.has( controller );
    }

    /**
     * Determines whether this Entity has all of the given controllers.
     * 
     * @param controllers
     *        The array of controllers to test for existence.
     * @return True if the entity has all given controllers, otherwise false.
     */
    public boolean has( Controller... controllers )
    {
        return template.has( controllers );
    }

    /**
     * Determines whether this Entity has all of the given controllers
     * specified in the BitSet, where the 0th bit is the controller with
     * an ID of zero.
     * 
     * @param controllers
     *        The BitSet of controller identifiers.
     * @return True if the entity has all given controllers, otherwise false.
     */
    public boolean hasControllers( BitSet controllers )
    {
        return template.controllerBitSet.contains( controllers );
    }

    /*
     * Component Functions
     */

    /**
     * Determines whether this entity has the given component (or an
     * alternative).
     * 
     * @param component
     *        The component to test for.
     * @return True if this Entity has the component (or an alternative),
     *         otherwise false.
     */
    public boolean has( Component<?> component )
    {
        return template.has( component );
    }

    /**
     * Determines whether this entity has all of the given components (or their
     * alternatives).
     * 
     * @param components
     *        The set of components to test for.
     * @return True if this entity has all of the components (or their
     *         alternatives), otherwise false.
     */
    public boolean has( Component<?>... components )
    {
        return template.has( components );
    }

    /**
     * Determines whether this entity has all of the given components specified
     * by a BitSet, where the i'th bit in the set is set to true to indicate the
     * component with the ID equaling "i" is present.
     * 
     * @param components
     *        The BitSet of components.
     * @return True if this entity has all of the components specified in the
     *         BitSet, otherwise false.
     */
    public boolean hasComponents( BitSet components )
    {
        return template.componentBitSet.contains( components );
    }

    /**
     * Returns the value of the component on this Entity. This is an unsafe
     * method, meaning if the Entity does not have the component then a
     * {@link NullPointerException} will be thrown. This method is also the
     * fastest way of getting an Entity's component value. <br/>
     * <br/>
     * {@link #gets(Component)} or {@link #gets(Component, Object)} should be
     * used to safely get a value of a component. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     * 
     * @param component
     *        The component to get the value of.
     * @return The value of the component on this Entity.
     * @throws NullPointerException
     *         The component does not exist on this Entity.
     */
    public <T> T get( Component<T> component )
    {
        TemplateComponent<T> ch = (TemplateComponent<T>)template.handlers[component.id];
        return ch.get( this );
    }

    /**
     * Returns the value of the component on this Entity or null if this entity
     * does not have the given component. This is a safer, although slightly
     * slower, alternative to {@link #get(Component)}. An alternative method to
     * this is {@link #gets(Component, Object)} which returns a defined value if
     * the Entity doesn't have the component. <br/>
     * <br/>
     * {@link #get(Component)} should be used if you are confident an Entity has
     * the component, or if you want an exception to be thrown to indicate a
     * logical error in your code. <br/>
     * <br/>
     * The return value of null should not be used as an indicator to whether an
     * Entity has a component, since null is a valid component value. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     * 
     * @param component
     *        The component to get the value of.
     * @return The value of the component on this Entity or null.
     */
    public <T> T gets( Component<T> component )
    {
        return template.has( component ) ? get( component ) : null;
    }

    /**
     * Returns the value of the component on this Entity or given missingValue
     * if this entity does not have the given component. This is a safer,
     * although slightly slower, alternative to {@link #get(Component)}. An
     * alternative method to this is {@link #gets(Component)} which returns null
     * if the Entity doesn't have the component. <br/>
     * <br/>
     * {@link #get(Component)} should be used if you are confident an Entity has
     * the component, or if you want an exception to be thrown to indicate a
     * logical error in your code. <br/>
     * <br/>
     * The return value matching (by reference) the missingValue passed in
     * should
     * not be used as an indicator to whether an Entity has a component, since
     * missingValue could actually exist on the Entity. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     * 
     * @param component
     *        The component to get the value of.
     * @return The value of the component on this Entity or missingValue.
     */
    public <T> T gets( Component<T> component, T missingValue )
    {
        return template.has( component ) ? get( component ) : missingValue;
    }

    /**
     * Sets the value of the component on this Entity. This is an unsafe method,
     * meaning if the Entity does not have the component then a
     * {@link NullPointerException} will be thrown. This method is also the
     * fastest way of setting an Entity's component value. <br/>
     * <br/>
     * {@link #sets(Component, Object)} should be used to safely set the value
     * of a component on the Entity. <br/>
     * <br/>
     * Depending on the component type, the value set may be a value that is
     * shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * set value, or it may be an aliased value (existing under a different
     * component in reality).
     * 
     * @param component
     *        The component to set the value of.
     * @param value
     *        The new value of the component.
     * @throws NullPointerException
     *         The component does not exist on this Entity.
     */
    public <T> void set( Component<T> component, T value )
    {
        TemplateComponent<T> ch = (TemplateComponent<T>)template.handlers[component.id];
        ch.set( this, value );
    }

    /**
     * Sets the value of the component on this Entity and returns true, or
     * returns false if this Entity does not have the given component. This is a
     * safe yet slower alternative to {@link #set(Component, Object)}, thus will
     * not result in an exception being thrown. <br/>
     * <br/>
     * {@link #set(Component, Object)} should be used if you are confident an
     * Entity has the component, or if you want an exception to be thrown to
     * indicate a logical error in your code. <br/>
     * <br/>
     * Depending on the component type, the value set may be a value that is
     * shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * set value, or it may be an aliased value (existing under a different
     * component in reality).
     * 
     * @param component
     *        The component to set the value of.
     * @param value
     *        The new value of the component.
     * @return True if the Entity has the component and the value was set,
     *         otherwise false.
     */
    public <T> boolean sets( Component<T> component, T value )
    {
        boolean has = template.has( component );

        if (has)
        {
            set( component, value );
        }

        return has;
    }

    /**
     * Sets target to the value of the given component on this Entity and
     * returns target. This is not a safe method and will result in a
     * {@link NullPointerException} if the entity does not contain the
     * component, however it is the quicker method. <br/>
     * <br/>
     * This is useful when a dynamic component could be in use, depending on the
     * {@link DynamicValue} implementation it may save on unnecessarily creating
     * a short-lived object. <br/>
     * <br/>
     * {@link #takes(Component, Object)} should be used as the safe alternative
     * to this method. <br/>
     * <br/>
     * Not all component types may support taking, therefore a reference to an
     * object other than target may be returned.
     * 
     * @param component
     *        The component to take the value of.
     * @param target
     *        The target value to set and return with the component's value.
     * @return The reference to target, or the reference to another object if
     *         taking is not supported by the component on this Entity.
     * @throws NullPointerException
     *         The component does not exist on this Entity.
     */
    public <T> T take( Component<T> component, T target )
    {
        TemplateComponent<T> ch = (TemplateComponent<T>)template.handlers[component.id];
        return ch.take( this, target );
    }

    /**
     * Sets target to the value of the given component on this Entity and
     * returns target. This is the safe alternative to
     * {@link #take(Component, Object)} and will return null if this Entity does
     * not have the given component. <br/>
     * <br/>
     * This is useful when a dynamic component could be in use, depending on the
     * {@link DynamicValue} implementation it may save on unnecessarily creating
     * a short-lived object. <br/>
     * <br/>
     * {@link #take(Component, Object)} should be used if you are confident an
     * Entity has the component, or if you want an exception to be thrown to
     * indicate a logical error in your code. <br/>
     * <br/>
     * Not all component types may support taking, therefore a reference to an
     * object other than target may be returned.
     * 
     * @param component
     *        The component to take the value of.
     * @param target
     *        The target value to set and return with the component's value.
     * @return The reference to target, null, or the reference to another object
     *         if taking is not supported by the component on this Entity.
     * @throws NullPointerException
     *         The component does not exist on this Entity.
     */
    public <T> T takes( Component<T> component, T target )
    {
        return has( component ) ? take( component, target ) : null;
    }

    /*
     * Dynamic Functions
     */

    /**
     * Dynamically adds the given component to this Entity. If this Entity
     * already has this component exactly, this method has no affect. If this
     * Entity already has an alternative to this component, then this method
     * will still create a template and replace the alternative with the
     * component given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively. <br/>
     * <br/>
     * 
     * @param component
     *        The component to add or to replace the alternative with.
     */
    public <T> void add( Component<T> component )
    {
        setTemplate( template.addCustomComponent( component, this ) );
    }

    /**
     * Dynamically adds the given component to this Entity. If this Entity
     * already has this component exactly, this method has no affect. If this
     * Entity already has an alternative to this component, then this method
     * will still create a template and replace the alternative with the
     * component given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param component
     *        The component to add or to replace the alternative with.
     * @param defaultValue
     *        The default value for the component.
     * @see #add(Component)
     * @see #set(Component, Object)
     */
    public <T> void add( Component<T> component, T defaultValue )
    {
        add( component );
        set( component, defaultValue );
    }

    /**
     * Forces the value and component into this entity. If the given component
     * or an alternative doesn't exist, the given component is added to this
     * Entity. Once it's verified the component exists on the entity, the
     * component's value is set to the given value. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param component
     *        The component to force on the entity.
     * @param value
     *        The value of the forced component.
     * @return True if the component had to be added, otherwise false.
     */
    public <T> boolean put( Component<T> component, T value )
    {
        boolean missing = !template.has( component );

        if (missing)
        {
            add( component );
        }

        set( component, value );

        return missing;
    }

    /**
     * Forcefully takes the value of the component from this Entity. If the
     * given component or an alternative doesn't exist, the given component is
     * added to this Entity. Once it's verified the component exists on the
     * entity, the component's value is returned. In the event that the
     * component was dynamically added, the default value will be returned. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param component
     *        The component to grab the value of, and potentially add to this
     *        Entity if it doesn't exist already.
     * @return The grabbed value of the component on this Entity.
     */
    public <T> T grab( Component<T> component )
    {
        boolean missing = !template.has( component );

        if (missing)
        {
            add( component );
        }

        return get( component );
    }

    /**
     * Dynamically adds the given controller to this Entity. If this Entity
     * already has this controller exactly, this method has no affect. If this
     * Entity already has an alternative to this controller, then this method
     * will still create a template and replace the alternative with the
     * controller given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * This will also enable the controller. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param controller
     *        The controller to add or to replace the alternative with.
     */
    public void add( Controller controller )
    {
        setTemplate( template.addCustomController( controller ) );

        controllerEnabled.set( template.indexOf( controller ) );
    }

    /**
     * Dynamically sets the view of this Entity. If this Entity already has this
     * view exactly, this method has no affect. If this Entity already has an
     * alternative to this view, then this method will still create a template
     * and replace the alternative with the view given. If this Entity does not
     * already have it's own Template, one will be given. <br/>
     * <br/>
     * If the view given is a new one, the {@link #setRenderer(Renderer)} method
     * of this Entity will be invoked with the renderer on the given view. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param view
     *        The view to set on this Entity.
     */
    public void setView( View view )
    {
        if (setTemplate( template.setCustomView( view ) ))
        {
            setRenderer( template.createRenderer() );
        }
    }

    /**
     * Dynamically adds an aliased component to this Entity. This ensures when
     * any component methods (like {@link #get(Component)}) are invoked with the
     * alias component, the subject component will actually be used. If this
     * Entity already has the alias added, then this method has no affect. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     * 
     * @param subject
     *        The component to use when alias is passed in to component methods.
     * @param alias
     *        The component which appears to be on this Entity, but isn't.
     */
    public <T> void alias( Component<T> subject, Component<T> alias )
    {
        setTemplate( template.setCustomAlias( subject, alias ) );
    }

    /**
     * Sets the renderer of this Entity. If this entity already has a Renderer,
     * this Entity is removed from it by calling
     * {@link Renderer#destroy(Entity)}. The renderer of this entity is set
     * to the value of {@link Renderer#create(Entity)} if newRenderer is not
     * null.
     * 
     * @param newRenderer
     *        The new renderer of this Entity.
     */
    public void setRenderer( Renderer newRenderer )
    {
        if (renderer != newRenderer)
        {
            if (renderer != null)
            {
                renderer.destroy( this );
            }

            renderer = (newRenderer == null ? null : newRenderer.create( this ));
        }
    }

    /*
     * Cloning
     */

    /**
     * Creates a deep or shallow clone of this Entity. A deep clone is an exact
     * replica of this Entity but the component values are independent - if you
     * change one it doesn't change on the parent entity. A shallow clone
     * has the same component value references, so a change to one changes the
     * other.
     * 
     * @param deep
     *        True for a deep clone, false for a shallow clone.
     * @return A new Entity that is a clone of this Entity.
     */
    public Entity clone( boolean deep )
    {
        return cloneState( new Entity( template, template.createClonedValues( values, deep ), renderer ) );
    }

    /**
     * Clones the state of this entity to the given entity.
     * 
     * @param e
     *        The entity to clone this Entity's state to.
     * @return The given entity e.
     */
    protected <E extends Entity> E cloneState( E e )
    {
        e.controllerEnabled.clear();
        e.controllerEnabled.or( controllerEnabled );
        e.enabled = enabled;
        e.visible = visible;

        return e;
    }

    /**
     * Performs a dynamic merging of a given entity into this Entity. All
     * components, controllers, and view on the given entity that don't exist
     * in this entity are dynamically added and set to this Entity. If
     * overwrite is specified, then the components that are on the given Entity
     * are forcefully added overwriting any alternatives that exist on this
     * Entity.
     * 
     * @param entity
     *        The entity to merge into this Entity.
     * @param overwrite
     *        True if the entity to merge should force it's specific component,
     *        controller, and view implementations onto this Entity.
     * @return The reference to this Entity.
     */
    public Entity merge( Entity entity, boolean overwrite )
    {
        Template template = entity.template;

        for (Component<?> component : template.components)
        {
            if (overwrite || !has( component ))
            {
                add( component );
            }
        }

        for (Controller controller : template.controllers)
        {
            if (overwrite || !has( controller ))
            {
                add( controller );
            }
        }

        if (overwrite || !hasView())
        {
            setView( template.view );
        }

        return this;
    }

    /**
     * The {@link Template} of this Entity. The template contains all meta-data
     * about the components, controllers, and view on this Entity. This template
     * may be the template passed into the constructor, or it may be a template
     * dynamically created when a dynamic method (like {@link #add(Component)})
     * was invoked on a new component/controller/view.
     * 
     * @return The reference to the Template of this Entity.
     */
    public Template getTemplate()
    {
        return template;
    }

    /**
     * Determines whether this Entity has a custom template (which is true for
     * entities that have had components, controllers, or views dynamically
     * added to them).
     * 
     * @return True if this is a custom entity, otherwise false.
     */
    public boolean isCustom()
    {
        return template.isCustom();
    }

    /**
     * Returns the distinct values of this Entity. The order of these values is
     * dependent on the order of distinct components added to this Entity's
     * template. The returned value should not be modified.
     * 
     * @return The reference to the array backing this Entity's distinct values.
     */
    public Object[] getValues()
    {
        return values;
    }

    /**
     * The BitSet of controllers that are active on this Entity. The returned
     * value should not be modified.
     * 
     * @return The reference to the enabled controller flags {@link BitSet}.
     */
    public BitSet getControllerFlags()
    {
        return controllerEnabled;
    }

    /**
     * Returns the number of entities within this Entity. This should always be
     * at least one since this Entity is included in the size.
     * 
     * @return The number of entities in this Entity (including this).
     */
    protected int getEntitySize()
    {
        return 1;
    }

    /**
     * Returns the reference to the entity at the given position within this
     * Entity. The index must be greater than or equal to 0 and less than
     * {@link #getEntitySize()}.
     * 
     * @param index
     *        The index of the entity to return.
     * @return The reference to the entity at the given index.
     */
    protected Entity getEntity( int index )
    {
        return this;
    }

    /**
     * Returns the index that when passed into {@link #getEntity(int)} will
     * return the reference to this Entity.
     * 
     * @return The index of this entity.
     */
    protected int getEntityIndex()
    {
        return 0;
    }

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( '[' );

        if (template != null)
        {
            for (Component<?> c : template.components)
            {
                if (sb.length() > 1)
                {
                    sb.append( ',' );
                }

                sb.append( c.name );
                sb.append( '=' );
                sb.append( get( c ) );
            }
        }
        else
        {
            sb.append( "DELETED" );
        }

        sb.append( ']' );

        return sb.toString();
    }

    @Override
    public int hashCode()
    {
        final int prime = 31;
        int result = 1;

        for (Component<?> c : template.components)
        {
            Object v = get( c );

            result = prime * result + (v == null ? 0 : v.hashCode());
        }

        return result;
    }

    @Override
    public boolean equals( Object obj )
    {
        if (obj == null || !(obj instanceof Entity))
        {
            return false;
        }
        if (obj == this)
        {
            return true;
        }

        Entity e = (Entity)obj;

        // First check they both have the same components.
        if (!template.componentBitSet.equals( e.template.componentBitSet ))
        {
            return false;
        }

        // Iterate through all components, compare values.
        for (Component<?> c : template.components)
        {
            if (!EntityUtility.equals( get( c ), e.get( c ) ))
            {
                return false;
            }
        }

        return true;
    }

}
